---
title: Git使用 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


# Git介绍

## 什么是版本控制系统？

版本控制系统或VCS在人员和团队一起协作项目时跟踪更改历史记录。随着项目的发展，团队可以运行测试，修复错误并提供新代码，并确信任何版本都可以随时恢复。开发人员可以查看项目历史记录以找出：

- 进行了哪些更改？
- 谁做出了改变？
- 什么时候做出改变？
- 为什么需要更改？

## 什么是分布式版本控制系统？

Git是通常用于开源和商业软件开发的分布式版本控制系统（DVCS）的示例。DVCS允许完全访问项目的每个文件，分支和迭代，并允许每个用户访问所有更改的完整且自包含的历史记录。与曾经流行的集中式版本控制系统不同，像Git这样的DVCS不需要与中央存储库的持续连接。开发人员可以在任何地方工作，并可以从任何时区异步协作。

如果没有版本控制，团队成员将受到冗余任务，较慢的时间线和单个项目的多个副本的限制。为了消除不必要的工作，Git和其他VCS为每个贡献者提供了一个统一且一致的项目视图，展示了正在进行的工作。查看变更的透明历史，制作变更的人员以及他们如何为项目的开发做出贡献有助于团队成员在独立工作时保持一致。

## 为什么Git？

根据最新的Stack Overflow开发人员调查，超过70％的开发人员使用Git，使其成为世界上使用最多的VCS。Git通常用于开源和商业软件开发，对个人，团队和企业都有很大的好处。

- Git允许开发人员在一个地方查看他们的变更，决策和任何项目进展的整个时间表。从他们访问项目历史的那一刻起，开发人员就拥有了解它并开始贡献所需的所有上下文。

- 开发人员在每个时区工作。使用像Git这样的DVCS，可以在保持源代码完整性的同时进行协作。使用分支，开发人员可以安全地建议更改生产代码。

- 使用Git的企业可以打破团队之间的沟通障碍，让他们专注于做最好的工作。此外，Git使整个企业的专家能够在重大项目上进行协作。

## 什么是存储库？

一个仓库，或Git项目，包括与项目相关的文件和文件夹的整个集合，每个文件的修订历史记录一起。文件历史记录显示为称为提交的快照，并且提交作为链接列表关系存在，并且可以组织成称为分支的多个开发行。由于Git是DVCS，因此存储库是自包含单元，拥有存储库副本的任何人都可以访问整个代码库及其历史记录。使用命令行或其他易用的接口，git存储库还允许：与历史记录交互，克隆，创建分支，提交，合并，比较代码版本之间的更改等。

在存储库中工作可以使开发项目得到组织和保护。鼓励开发人员修复错误或创建新功能，而不必担心破坏主线开发工作。Git通过使用主题分支来实现这一点：历史记录中的提交的轻量级指针可以在不再需要时轻松创建和弃用。

通过像GitHub这样的平台，Git还为项目透明度和协作提供了更多机会。公共存储库可帮助团队协同工作，以构建最佳的最终产品。

## 基本Git命令

要使用Git，开发人员使用特定命令来复制，创建，更改和组合代码。这些命令可以直接从命令行执行，也可以使用GitHub Desktop或Git Kraken 等应用程序执行。以下是使用Git的一些常用命令：

- `git init`初始化一个全新的Git存储库并开始跟踪现有目录。它在现有目录中添加了一个隐藏的子文件夹，其中包含版本控制所需的内部数据结构。

- `git clone`创建已远程存在的项目的本地副本。克隆包括所有项目的文件，历史记录和分支。

- `git add`发生变化。Git跟踪对开发人员代码库的更改，但是有必要暂存并拍摄更改的快照以将其包含在项目的历史记录中。此命令执行分段，这是两步过程的第一部分。任何已暂存的更改都将成为下一个快照的一部分，并成为项目历史的一部分。分别进行分段和提交可使开发人员完全控制其项目的历史记录，而无需更改其编码和工作方式。

- `git commit`将快照保存到项目历史记录中并完成更改跟踪过程。简而言之，提交功能就像拍照片一样。任何已经上演的东西都git add将成为快照的一部分git commit。

- `git status` 将更改状态显示为未跟踪，已修改或已暂存。

- `git branch` 显示在本地工作的分支。

- `git merge`将发展线融合在一起。此命令通常用于组合在两个不同分支上进行的更改。例如，当开发人员想要将来自功能分支的更改组合到主分支以进行部署时，他们会合并。

- `git pull`使用远程对应的更新更新本地开发线。如果队友已经对远程分支进行了提交，开发人员会使用此命令，并且他们希望在本地环境中反映这些更改。

- `git push` 使用本地提交给分支的任何提交来更新远程存储库。

# Git 手册

## git
### 名称
git
### 概要
git [-- version]  [- help] [-C &lt;path&gt; ]  [-c &lt;name&gt; = &lt;value&gt;]
&nbsp;&nbsp;&nbsp;&nbsp;[--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] 
&nbsp;&nbsp;&nbsp;&nbsp;[-p | --paginate | -P | --no-pager] [ -no- replace-objects]
&nbsp;&nbsp;&nbsp;&nbsp;[--bare] [--git-dir = &lt;path&gt;] [ -  work-tree = &lt;path&gt;] [--namespace = &lt;name&gt;]
&nbsp;&nbsp;&nbsp;&nbsp;[--super-prefix = &lt;path&gt;]  &lt;command&gt; [&lt;args&gt;]
### 描述
Git是一个快速，可扩展的分布式版本控制系统，具有异常丰富的命令集，可提供高级操作和对内部的完全访问。
### OPTIONS
**`--version`**

打印git程序的Git套件版本信息

**`--help`**

打印概要和最常用命令的列表。如果选择--all或-a，则打印所有可用命令。如果命名了Git命令，则此选项将显示该命令的手册页

**`-C <path>`**

运行就好像git是在&lt;path&gt;而不是当前工作目录中启动的。当-C给出多个选项时，-C &lt;path&gt;相对于前面的每个后续非绝对值被解释-C &lt;path&gt;。

此选项会影响预期的路径名的选项一样--git-dir，并 --work-tree在他们的路径名的解释，将相对于所造成的工作目录进行-C选择。例如，以下调用是等效的：
```
git --git-dir=a.git --work-tree=b -C c status
git --git-dir=c/a.git --work-tree=c/b status
```

**`-c <name>=<value>`**

将配置参数传递给命令。给定的值将覆盖配置文件中的值。<name>的格式与git config列出的格式相同 （以点分隔的子键）。

**`--exec-path[=<path>]`**

安装核心Git程序的路径。这也可以通过设置GIT_EXEC_PATH环境变量来控制。如果没有给出路径，git将打印当前设置然后退出。

**`--html-path`**

打印路径，不带斜杠，安装Git的HTML文档并退出。

**`--man-path`**

打印manpath（请参阅参考资料man(1)）获取此版本Git的手册页并退出。

**`--info-path`**

打印安装记录此版本Git的Info文件的路径并退出。

**`-p`**
**`--paginate`**

如果标准输出是终端，则将所有输出传输到较少（或如果设置为$ PAGER）。这将覆盖pager.<cmd> 配置选项（请参阅下面的“配置机制”部分）。

**`-P`**
**`--no-pager`**

不要将Git输出传输到寻呼机。

**`--git-dir=<path>`**

设置存储库的路径。这也可以通过设置GIT_DIR环境变量来控制。它可以是当前工作目录的绝对路径或相对路径。

**`--work-tree=<path>`**

设置工作树的路径。它可以是绝对路径或相对于当前工作目录的路径。这也可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制（有关更详细的讨论，请参阅git-config（1）中的core.worktree ）。

**`--namespace=<path>`**

设置Git名称空间。有关更多详细信息，请参阅gitnamespaces（7）。相当于设置GIT_NAMESPACE环境变量。

**`--super-prefix=<path>`**

目前仅供内部使用。设置一个前缀，该前缀提供从存储库上方到其根目录的路径。一个用途是给出调用它的超级项目的子模块上下文。

**`--bare`**

将存储库视为裸存储库。如果未设置GIT_DIR环境，则将其设置为当前工作目录。

**`--no-replace-objects`**

不要使用替换refs来替换Git对象。有关更多信息，请参阅 git-replace（1）。

**`--literal-pathspecs`**

按字面意思处理pathspecs（即没有globbing，没有pathspec魔法）。这相当于将GIT_LITERAL_PATHSPECS环境变量设置为1。

**`--glob-pathspecs`**

为所有pathspec添加“glob”魔法。这相当于将GIT_GLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( literal）”在各个pathspecs上禁用globbing

**`--noglob-pathspecs`**

为所有pathspec添加“literal”魔法。这相当于将GIT_NOGLOB_PATHSPECS环境变量设置为1。可以使用pathspec magic“:( glob）”在各个pathspec上启用globbing

**`--icase-pathspecs`**

为所有pathspec添加“icase”魔法。这相当于将GIT_ICASE_PATHSPECS环境变量设置为1。

**`--no-optional-locks`**

不要执行需要锁定的可选操作。这相当于设置GIT_OPTIONAL_LOCKS为0。

**`--list-cmds=group[,group…]`**

按组列出命令。这是一个内部/实验选项，可能会在将来更改或删除。支持的组包括：builtins，parseopt（使用parse-options的内置命令），main（libexec目录中的所有命令），其他（其他所有命令$PATH都有git-前缀），list- <category>（请参阅命令中的类别 - list.txt），nohelpers（排除帮助程序命令），别名和配置（从配置变量completion.commands检索命令列表）

## git高级命令
### 主要命令
#### git-add
##### 名称
git add
##### 概要
git add [--verbose | -v] [ -  dr-run | -n] [--force | -f] [--interactive | -i] [ - 补丁| -p]
&nbsp;&nbsp;&nbsp;[--edit | -e] [ -  [no-] all |  -  [no-] ignore-removal | [ - 更新| -u]
&nbsp;&nbsp;&nbsp;[--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]
&nbsp;&nbsp;&nbsp;[--chmod =（+ |  - ）x] [ - ] [&lt;pathspec&gt; ...]
##### 描述
此命令使用工作树中找到的当前内容更新索引，以准备为下次提交暂存的内容。它通常会添加现有路径的当前内容作为一个整体，但是通过一些选项，它还可以用于添加仅对应用的工作树文件所做的部分更改的内容，或者删除工作树中不存在的路径了。

“index”保存工作树内容的快照，并将此快照作为下一次提交的内容。因此，在对工作树进行任何更改之后，在运行commit命令之前，必须使用该add命令将任何新的或已修改的文件添加到索引中。

在提交之前可以多次执行此命令。它只在添加命令运行时添加指定文件的内容; 如果您希望下次提交中包含后续更改，则必须git add再次运行以将新内容添加到索引中。

该git status命令可用于获取哪些文件具有为下次提交而暂存的更改的摘要。

git add默认情况下，该命令不会添加被忽略的文件。如果在命令行上显式指定了任何被忽略的文件，git add 则将失败并显示一个被忽略的文件列表。由Git执行的目录递归或文件名通配所达到的忽略文件（在shell之前引用你的globs）将被默默忽略。在git的添加命令可以用来添加与被忽略的文件-f（强制）选项。

##### 选项
**`<pathspec>…`**

要添加内容的文件。*.c可以给Fileglobs（例如）添加所有匹配的文件。还可以给出一个主要目录名称（例如dir添加dir/file1 和dir/file2）以更新索引以匹配整个目录的当前状态（例如，指定dir将不仅记录dir/file1 在工作树中修改的文件，dir/file2添加到工作的文件树，但也dir/file3从工作树中删除了一个文件。请注意，旧版本的Git用于忽略已删除的文件; --no-all如果要添加已修改或新文件但忽略已删除的文件，请使用选项。

**`-n`**
**`--dry-run`**

不要实际添加文件，只显示它们是否存在和/或将被忽略。


### 辅助命令
### 与他人互动
## git低级命令
### 操纵命令
### 询问命令
### 同步存储库
### 内部帮助器命令




